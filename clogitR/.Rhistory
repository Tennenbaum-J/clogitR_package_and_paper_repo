pacman::p_load(SeqExpMatch, dplyr, data.table)
library(ggplot2)
rm(list = ls())
options(error = recover)
#n = 50
#p = 2
mu_x = 1
sigma_x = 1
sigma_e = 1
nsim_exact_test = 501
num_cores = 1
Nsim = 10
#build mvnp covariates
set.seed(1)
all_betas_and_correlations = list()
all_betas_and_correlations = c(all_betas_and_correlations, list(list(p = 2, rho = 0,     betas = c(1, -3, 1.5, 0, 0))))
all_betas_and_correlations = c(all_betas_and_correlations, list(list(p = 2, rho = 0.75,  betas = c(1, -3, 1.5, 0, 0))))
all_betas_and_correlations = c(all_betas_and_correlations, list(list(p = 2, rho = 0,     betas = c(0.5, -2, 1, 0, 0))))
all_betas_and_correlations = c(all_betas_and_correlations, list(list(p = 2, rho = 0.75,  betas = c(0.5, -2, 1, 0, 0))))
all_betas_and_correlations = c(all_betas_and_correlations, list(list(p = 4, rho = 0,     betas = c(1, -2, 1, 1.5, -2))))
all_betas_and_correlations = c(all_betas_and_correlations, list(list(p = 4, rho = 0.75,  betas = c(1, -2, 1, 1.5, -2))))
all_betas_and_correlations = c(all_betas_and_correlations, list(list(p = 20, rho = 0,     betas = c(1, -2, 1, 1.5, -2,
0, 0, -1, -3, 2,
1, -2, 0, 1.4, 0,
-1.3, -2, 3, 1, 1
))))
all_betas_and_correlations = c(all_betas_and_correlations, list(list(p = 20, rho = 0.75,  betas = c(1, -2, 1, 1.5, -2,
0, 0, -1, -3, 2,
1, -2, 0, 1.4, 0,
-1.3, -2, 3, 1, 1
))))
plots_list = list()
plot_index = 1
comparison = data.frame(
n = numeric(),
beta_T = numeric(),
p = numeric(),
num_discord = numeric(),
Rcpp_beta_hat_T = numeric(),
Rcpp_sse_beta_T = numeric(),
clogit_beta_hat_T = numeric(),
clogit_sse_beta_T = numeric(),
glm_beta_hat_T = numeric(),
glm_sse_beta_T = numeric(),
swaped = numeric()
)
to_few_discordant = list()
res = data.frame(
betas = character(),
beta_T = numeric(),
n = numeric(),
rho = numeric(),
design = character(),
infrence = character(),
beta_hat_T = numeric(),
pval = numeric()
)
times = rep(NA, Nsim)
for (nsim in 1 : Nsim){
start_time = Sys.time()
cat ("nsim:", nsim, "/", Nsim, "\n")
#tryCatch({
for (beta_T in c(0,1)){
for (n in c(50, 100, 500, 1000)){ #50, 100, 500, 1000
errors = rnorm(n, 0, sigma_e)
for (all_betas_and_correlation in all_betas_and_correlations){
p = all_betas_and_correlation[["p"]]
betas = all_betas_and_correlation[["betas"]]
rho = all_betas_and_correlation[["rho"]]
Sigma = sigma_x * (matrix(rho, nrow = p, ncol = p) + diag(1 - rho, p))
X = data.table(MASS::mvrnorm(n, rep(mu_x, p), Sigma))
if (p == 2){
z = betas[1] * X[, 1] +
betas[2] * X[, 2] +
betas[3] * X[, 1]^2 +
betas[4] * X[, 2]^2 +
betas[5] * X[, 1] * X[, 2]
} else if (p == 4){
z = betas[1] * X[, 1] +
betas[2] * X[, 2] +
betas[3] * X[, 1]^2 +
betas[4] * X[, 3] +
betas[5] * X[, 4]
} else {
z = betas[1] * X[, 1] +
betas[2] * X[, 2] +
betas[3] * X[, 3] +
betas[4] * X[, 4] +
betas[5] * X[, 5] +
betas[6] * X[, 6] +
betas[7] * X[, 7] +
betas[8] * X[, 8] +
betas[9] * X[, 9] +
betas[10] * X[, 10] +
betas[11] * X[, 11] +
betas[12] * X[, 12] +
betas[13] * X[, 13] +
betas[14] * X[, 14] +
betas[15] * X[, 15] +
betas[16] * X[, 16] +
betas[17] * X[, 17] +
betas[18] * X[, 18] +
betas[19] * X[, 19] +
betas[20] * X[, 20]
}
probs = rep(NA, n)
y = rep(NA, n)
#test all designs
for (d in c("KK21")){ #"KK14", , "KK21stepwise"
des = paste0("SeqDesign", d)
des_class = get(des)
seq_des_obj = des_class$new(n = n, prob_T = 0.5, p = p, response_type = "incidence", verbose = FALSE, morrison = FALSE)
#cat(beta_T, n, rho, ' ', paste0(betas, collapse=""),'\n')
for (t in 1 : n){
seq_des_obj$add_subject_to_experiment_and_assign(X[t, ])
w_t = seq_des_obj$get_w()[seq_des_obj$get_t()]
probs[t] = 1 / (1 + exp(-(beta_T * w_t + as.numeric(z[t]) + errors[t])))
y[t] = rbinom(1, 1, (probs[t]))
seq_des_obj$add_subject_response(t = t, y = as.numeric(y[t]))
}
df = data.frame(
p = probs,
y = y
)
# plots_list[[plot_index]] =
#   ggplot(df, aes(x = p, fill = factor(y))) +
#     geom_histogram(position = "identity", alpha = 0.6, bins = 30) +
#     labs(x = "Predicted probability", fill = "Outcome", title = paste(beta_T, n, rho, paste0(betas, collapse=""), d, sep = " ")) +
#     scale_fill_manual(values = c("0" = "red", "1" = "blue")) +
#     theme_minimal()
# plot_index = plot_index + 1
matched_inference = SeqDesignInferenceIncidConditionalLogRegrKK$new(seq_des_obj, num_cores = 1, convex_flag = TRUE, verbose = FALSE)
mixed_inference = SeqDesignInferenceIncidConditionalLogRegrKK$new(seq_des_obj, num_cores = 1, convex_flag = FALSE, verbose = FALSE)
#cat("bata  : ", sprintf("%.3f", beta_T), ' ', sprintf("%.3f", betas[1]), ' ', sprintf("%.3f", betas[2]), '\n')
matched_beta_hat_T = matched_inference$compute_treatment_estimate()
matched_pval = matched_inference$compute_mle_two_sided_pval_for_treatment_effect()
mixed_beta_hat_T = mixed_inference$compute_treatment_estimate()
mixed_pval = mixed_inference$compute_mle_two_sided_pval_for_treatment_effect()
#cat('\n')
if(!is.null(matched_inference$get_graphing_data()$Rcpp_beta_hat_T)){
comparison = rbind(comparison, data.frame(
n = n,
beta_T = beta_T,
p = p,
num_discord = matched_inference$get_graphing_data()$num_discord,
Rcpp_beta_hat_T = matched_inference$get_graphing_data()$Rcpp_beta_hat_T,
Rcpp_sse_beta_T = matched_inference$get_graphing_data()$Rcpp_sse_beta_T,
clogit_beta_hat_T = matched_inference$get_graphing_data()$clogit_beta_hat_T,
clogit_sse_beta_T = matched_inference$get_graphing_data()$clogit_sse_beta_T,
glm_beta_hat_T = matched_inference$get_graphing_data()$glm_beta_hat_T,
glm_sse_beta_T = matched_inference$get_graphing_data()$glm_sse_beta_T,
swaped = matched_inference$get_graphing_data()$swaped
))
to_few_discordant = c(to_few_discordant, 0)
} else {
to_few_discordant = c(to_few_discordant, 1)
}
res = rbind(res, data.frame(
betas = paste0(betas, collapse=""),
beta_T = beta_T,
n = n,
rho = rho,
design = d,
infrence = "matched",
beta_hat_T = matched_beta_hat_T,
pval = matched_pval
))
res = rbind(res, data.frame(
betas = paste0(betas, collapse=""),
beta_T = beta_T,
n = n,
rho = rho,
design = d,
infrence = "mixed",
beta_hat_T = mixed_beta_hat_T,
pval = mixed_pval
))
}
}
}
}
times[nsim] = Sys.time() - start_time
print(Sys.time() - start_time)
# }, error = function(e) {
#   message(paste("⚠️ Error in nsim =", nsim, ":", conditionMessage(e)))
#   times[nsim] = NA
# })
}
ggplot(data = comparison, aes(x = num_discord, fill = factor(swaped))) +
geom_histogram() +
xlim(0,100) +
facet_wrap(~ p)
ggplot(data = comparison, aes(x = num_discord, fill = factor(swaped))) +
geom_histogram() +
facet_wrap(~ p)
pacman::p_load(SeqExpMatch, dplyr, data.table, doFuture, future, doRNG, foreach, progressr, doParallel) #doParallel
rm(list = ls())
set.seed(1986)
options(error = recover)
p = 2
mu_x = 1
sigma_x = 1
sigma_e = 1
nsim_exact_test = 501
num_cores = availableCores()-15
external_nsim = 1
Nsim = 10
beta_Ts = c(0, 1)
configs = list()
configs = c(configs, list(setting = list(rho = 0, 	betas = c(1, -3, 1.5, 0, 0))))
configs = c(configs, list(setting = list(rho = 0.75, 	betas = c(1, -3, 1.5, 0, 0))))
configs = c(configs, list(setting = list(rho = 0, 	betas = c(0.5, -2, 1, 0, 0))))
configs = c(configs, list(setting = list(rho = 0.75, 	betas = c(0.5, -2, 1, 0, 0))))
designs = c("KK21") #"KK14", "KK21", "KK21stepwise"
ns = c(50, 100, 500, 1000)
params = expand.grid(
i = 1:Nsim,
beta_T = beta_Ts,
config = configs,
n = ns,
design = designs,
KEEP.OUT.ATTRS = FALSE
)
params = params %>%
arrange(i, beta_T, config, n, design)
run_simulation = function(i, beta_T, config, design, n){
#cat("nsim:", i, ", 1\n")
res = data.frame(
i = numeric(),
beta_T = numeric(),
n = numeric(),
betas = character(),
rho = numeric(),
design = character(),
inference = character(),
beta_hat_T = numeric(),
pval = numeric()
)
errors = rnorm(n, 0, sigma_e)
betas = config$setting$betas
rho = config$setting$rho
Sigma = sigma_x * (matrix(rho, nrow = p, ncol = p) + diag(1 - rho, p))
X = data.table(MASS::mvrnorm(n, rep(mu_x, p), Sigma))
z = betas[1] * X[, 1] +
betas[2] * X[, 2] +
betas[3] * X[, 1]^2 +
betas[4] * X[, 2]^2 +
betas[5] * X[, 1] * X[, 2]
probs = rep(NA, n)
y = array(NA, n)
des = paste0("SeqDesign", design)
des_class = get(des)
seq_des_obj = des_class$new(n = n, prob_T = 0.5, p = p,
response_type = "incidence", verbose = FALSE)
for (t in 1 : n){
seq_des_obj$add_subject_to_experiment_and_assign(X[t, ])
w_t = seq_des_obj$get_w()[seq_des_obj$get_t()]
probs[t] = 1 / (1 + exp(-(beta_T * w_t + as.numeric(z[t]) + errors[t])))
y[t] = rbinom(1, 1, (probs[t]))
seq_des_obj$add_subject_response(t = t, y = as.numeric(y[t]))
}
rm(errors, Sigma, X, z, y, probs, t, des, des_class)
gc()
matched_inference = SeqDesignInferenceIncidConditionalLogRegrKK$new(seq_des_obj, num_cores = 1, convex_flag = TRUE, verbose = FALSE)
mixed_inference = SeqDesignInferenceIncidConditionalLogRegrKK$new(seq_des_obj, num_cores = 1, convex_flag = FALSE, verbose = FALSE)
#cat("bata  : ", sprintf("%.3f", beta_T), ' ', sprintf("%.3f", betas[1]), ' ', sprintf("%.3f", betas[2]), '\n')
matched_beta_hat_T = matched_inference$compute_treatment_estimate()
matched_pval = matched_inference$compute_mle_two_sided_pval_for_treatment_effect()
mixed_beta_hat_T = mixed_inference$compute_treatment_estimate()
mixed_pval = mixed_inference$compute_mle_two_sided_pval_for_treatment_effect()
#cat('\n')
res = rbind(res, data.frame(
i = i,
beta_T = beta_T,
n = n,
betas = paste0(betas, collapse=""),
rho = rho,
design = design,
infrence = "matched",
beta_hat_T = matched_beta_hat_T,
pval = matched_pval
))
res = rbind(res, data.frame(
i = i,
beta_T = beta_T,
n = n,
betas = paste0(betas, collapse=""),
rho = rho,
design = design,
infrence = "mixed",
beta_hat_T = mixed_beta_hat_T,
pval = mixed_pval
))
return(res)
}
handlers(global = TRUE)
handlers("txtprogressbar")
registerDoFuture()
plan(multisession, workers = num_cores)
start_time = Sys.time()
with_progress({
for (e_nsim in 1:external_nsim){
prog = progressor(along = 1:(nrow(params) * external_nsim))
results = foreach(row = iter(params, by = "row"), .combine = rbind, .packages = c("SeqExpMatch", "data.table", "dplyr")) %dorng% {
i = row$i
beta_T = row$beta_T
config = row$config
n = row$n
design = row$design
morison = row$morison
cat(glue::glue("Running i={i}, n={n}, design={design}"), '\n')
res = tryCatch({
out = run_simulation(i, beta_T, config, design, n)
cat("Successfully ran simulation")
prog()
out
}, error = function(e) {
cat(glue::glue("Error in sim i={i}, n={n}, design={design}, mor={morison}: {e$message}"), '\n')
prog()  # still update progress bar even if it fails
NULL    # return NULL if failed, will be dropped in rbind
})
}
write.csv(results, file = paste0("C:/temp/conditional_logistic_regression/conditional_100_", e_nsim, ".csv"), row.names = FALSE)
rm(results); gc()
}
})
warnings()
results = read.csv("C:/temp/conditional_logistic_regression/conditional_100_1.csv")
res_mod = results %>%
mutate(sq_err = (beta_hat_T - beta_T)^2, rej = pval < 0.05) %>%
group_by(betas, rho, beta_T, n, design, infrence) %>%
summarize(mse = mean(sq_err), percent_reject = sum(rej) / n())
res_mod
View(res_mod)
plan(sequential)
pacman::p_load(SeqExpMatch, dplyr, data.table, doFuture, future, doRNG, foreach, progressr, doParallel) #doParallel
rm(list = ls())
set.seed(1986)
options(error = recover)
p = 2
mu_x = 1
sigma_x = 1
sigma_e = 1
nsim_exact_test = 501
num_cores = availableCores()-14
external_nsim = 10
Nsim = 100
beta_Ts = c(0, 1)
configs = list()
configs = c(configs, list(setting = list(rho = 0, 	betas = c(1, -3, 1.5, 0, 0))))
configs = c(configs, list(setting = list(rho = 0.75, 	betas = c(1, -3, 1.5, 0, 0))))
configs = c(configs, list(setting = list(rho = 0, 	betas = c(0.5, -2, 1, 0, 0))))
configs = c(configs, list(setting = list(rho = 0.75, 	betas = c(0.5, -2, 1, 0, 0))))
designs = c("KK21") #"KK14", "KK21", "KK21stepwise"
ns = c(50, 100, 500, 1000)
params = expand.grid(
i = 1:Nsim,
beta_T = beta_Ts,
config = configs,
n = ns,
design = designs,
KEEP.OUT.ATTRS = FALSE
)
params = params %>%
arrange(i, beta_T, config, n, design)
run_simulation = function(i, beta_T, config, design, n){
#cat("nsim:", i, ", 1\n")
res = data.frame(
i = numeric(),
beta_T = numeric(),
n = numeric(),
betas = character(),
rho = numeric(),
design = character(),
inference = character(),
beta_hat_T = numeric(),
pval = numeric()
)
errors = rnorm(n, 0, sigma_e)
betas = config$setting$betas
rho = config$setting$rho
Sigma = sigma_x * (matrix(rho, nrow = p, ncol = p) + diag(1 - rho, p))
X = data.table(MASS::mvrnorm(n, rep(mu_x, p), Sigma))
z = betas[1] * X[, 1] +
betas[2] * X[, 2] +
betas[3] * X[, 1]^2 +
betas[4] * X[, 2]^2 +
betas[5] * X[, 1] * X[, 2]
probs = rep(NA, n)
y = array(NA, n)
des = paste0("SeqDesign", design)
des_class = get(des)
seq_des_obj = des_class$new(n = n, prob_T = 0.5, p = p,
response_type = "incidence", verbose = FALSE)
for (t in 1 : n){
seq_des_obj$add_subject_to_experiment_and_assign(X[t, ])
w_t = seq_des_obj$get_w()[seq_des_obj$get_t()]
probs[t] = 1 / (1 + exp(-(beta_T * w_t + as.numeric(z[t]) + errors[t])))
y[t] = rbinom(1, 1, (probs[t]))
seq_des_obj$add_subject_response(t = t, y = as.numeric(y[t]))
}
rm(errors, Sigma, X, z, y, probs, t, des, des_class)
gc()
matched_inference = SeqDesignInferenceIncidConditionalLogRegrKK$new(seq_des_obj, num_cores = 1, convex_flag = TRUE, verbose = FALSE)
mixed_inference = SeqDesignInferenceIncidConditionalLogRegrKK$new(seq_des_obj, num_cores = 1, convex_flag = FALSE, verbose = FALSE)
#cat("bata  : ", sprintf("%.3f", beta_T), ' ', sprintf("%.3f", betas[1]), ' ', sprintf("%.3f", betas[2]), '\n')
matched_beta_hat_T = matched_inference$compute_treatment_estimate()
matched_pval = matched_inference$compute_mle_two_sided_pval_for_treatment_effect()
mixed_beta_hat_T = mixed_inference$compute_treatment_estimate()
mixed_pval = mixed_inference$compute_mle_two_sided_pval_for_treatment_effect()
#cat('\n')
res = rbind(res, data.frame(
i = i,
beta_T = beta_T,
n = n,
betas = paste0(betas, collapse=""),
rho = rho,
design = design,
infrence = "matched",
beta_hat_T = matched_beta_hat_T,
pval = matched_pval
))
res = rbind(res, data.frame(
i = i,
beta_T = beta_T,
n = n,
betas = paste0(betas, collapse=""),
rho = rho,
design = design,
infrence = "mixed",
beta_hat_T = mixed_beta_hat_T,
pval = mixed_pval
))
return(res)
}
handlers(global = TRUE)
handlers("txtprogressbar")
registerDoFuture()
plan(multisession, workers = num_cores)
start_time = Sys.time()
with_progress({
for (e_nsim in 1:external_nsim){
prog = progressor(along = 1:(nrow(params) * external_nsim))
results = foreach(row = iter(params, by = "row"), .combine = rbind, .packages = c("SeqExpMatch", "data.table", "dplyr")) %dorng% {
i = row$i
beta_T = row$beta_T
config = row$config
n = row$n
design = row$design
morison = row$morison
cat(glue::glue("Running i={i}, n={n}, design={design}"), '\n')
res = tryCatch({
out = run_simulation(i, beta_T, config, design, n)
cat("Successfully ran simulation")
prog()
out
}, error = function(e) {
cat(glue::glue("Error in sim i={i}, n={n}, design={design}, mor={morison}: {e$message}"), '\n')
prog()  # still update progress bar even if it fails
NULL    # return NULL if failed, will be dropped in rbind
})
}
write.csv(results, file = paste0("C:/temp/conditional_logistic_regression/conditional_100_", e_nsim, ".csv"), row.names = FALSE)
rm(results); gc()
}
})
results = read.csv("C:/temp/conditional_logistic_regression/conditional_100_1.csv")
for (i in 2:10){
results = rbind(results, read.csv(paste0("C:/temp/conditional_logistic_regression/conditional_100_", i, ".csv")))
}
results$X = NULL
res_mod = results %>%
mutate(sq_err = (beta_hat_T - beta_T)^2, rej = pval < 0.05) %>%
group_by(betas, rho, beta_T, n, design, infrence) %>%
summarize(mse = mean(sq_err), percent_reject = sum(rej) / n())
write.csv(res_mod, file = "C:/temp/conditional_logistic_regression/combined_1000.csv", row.names = FALSE)
diamonds = MASS::diamonds
?MASS
??MASS
diamonds = diamonds
df = MASS::Boston
df
?MASS::Boston
mean(df$medv)
df$y = as.numeric(df$medv > mean(df$medv))
df
df$medv = NULL
df
mod = glm(y ~ ., data = df)
mod = glm(y ~ ., data = df, family = "binomial")
mod
summary(mod)
mod$formula
mod$model
mod$terms
mod$call
Rcpp::compileAttributes()
setwd("C:/Users/Jacob/clogitR/R")
Rcpp::compileAttributes()
setwd("C:/Users/Jacob/clogitR")
Rcpp::compileAttributes()
mod$data
mod$data = 1
mod$data
mod$coefficients
fit(mod)
mod$call
mod$model
View(mod)
??assertFlag
pacman::p_load(checkmate)
View(mod)
