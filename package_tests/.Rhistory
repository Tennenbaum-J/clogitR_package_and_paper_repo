beta_hat_T = as.numeric(model[1]); ssq_beta_hat_T = as.numeric(model[2])
pval = 2 * pnorm(min(c(-1,1) * (beta_hat_T / ssq_beta_hat_T)))
}, error = function(e) {
beta_hat_T <<- NA; ssq_beta_hat_T <<- NA; pval <<- NA
})
beta_hat_T
pval
########################### CLOGIT  ###########################
beta_hat_T = NA; ssq_beta_hat_T = NA; pval = NA
if (discordant_viabele) {
y_dis_0_1 = ifelse(y_dis == -1, 0, 1)
model = summary(glm(y_dis_0_1 ~ 0 + w_dis, family = "binomial"))$coefficients[1,c(1,2)]
beta_hat_T = model[1]; ssq_beta_hat_T = model[2]
pval = 2 * pnorm(min(c(-1,1) * (beta_hat_T / ssq_beta_hat_T)))
}
beta_hat_T
pval
########################### glmmTMB  ###########################
beta_hat_T = NA; ssq_beta_hat_T = NA; pval = NA
tryCatch({
fit_tmb = glmmTMB(
y ~ w + (1 | strat),
family = binomial(),
data   = data.frame(y, X, w, strat)
)
model = summary(fit_tmb)$coefficients$cond["w", c("Estimate", "Std. Error")]
beta_hat_T = model[1]; ssq_beta_hat_T = model[2]
pval = 2 * pnorm(min(c(-1,1) * (beta_hat_T / ssq_beta_hat_T)))
}, error = function(e) {
beta_hat_T <<- NA; ssq_beta_hat_T <<- NA; pval <<- NA
})
beta_hat_T
pval
########################### GEE  ###########################
beta_hat_T = NA; ssq_beta_hat_T = NA; pval = NA
tryCatch({
fit_gee = geeglm(
y ~ w,
id    = strat,
family = binomial(link = "logit"),
corstr = "exchangeable",
data   = data.frame(y, X, w, strat)
)
model = summary(fit_gee)$coefficients["w", c("Estimate", "Std.err")]
beta_hat_T = as.numeric(model[1]); ssq_beta_hat_T = as.numeric(model[2])
pval = 2 * pnorm(min(c(-1,1) * (beta_hat_T / ssq_beta_hat_T)))
}, error = function(e) {
beta_hat_T <<- NA; ssq_beta_hat_T <<- NA; pval <<- NA
})
beta_hat_T
pval
pacman::p_load(clogitR, dplyr, data.table, doFuture, future, doRNG, foreach, progressr, doParallel, nbpMatching, doParallel, ggplot2, geepack, glmmTMB, rstan) #doParallel
options(error = recover)
rm(list = ls())
############### parameters ###############
num_cores = availableCores() - 4
Nsim = 100
external_nsim = 100000
ns = c(100, 250, 500)
beta_Ts = c(0,1)
X_styles = c("correlated", "non-correlated")
true_funtions = c("linear", "non-linear")
regress_on_Xs = c("all", "one", "none")
params = expand.grid(
nsim = 1:Nsim,
beta_T = beta_Ts,
n = ns,
X_style = X_styles
)
params = params %>%
arrange(nsim, beta_T, n, X_style)
Bayesian_Clogit = function(y_dis, X_dis, w_dis, y_con, X_con, w_con, inculde_prior_for_beta_T) {
fit_con = glm(y_con ~ w_con + X_con, family = "binomial")
b_con = summary(fit_con)$coefficients[,1]
Sigma_con = pmin(vcov(fit_con), 20)
if (inculde_prior_for_beta_T) {
b_con = b_con[-1]
Sigma_con = Sigma_con[-1,-1]
} else {
b_con = c(0, b_con[-c(1,2)])
Sigma_con = Sigma_con[-1,-1]; Sigma_con[1,] = 0; Sigma_con[, 1] = 0; Sigma_con[1,1] = 20
}
if (all(diag(Sigma_con) == 20)) {
ret = list()
ret$betaT = NA
ret$ssq_beta_T = NA
ret$reject = NA
ret$pval = NA
return(ret)#model blew up
}
y_dis_0_1 = ifelse(y_dis == -1, 0, 1)
X_dis = cbind(w_dis, X_dis)
data_list = list(
N = nrow(X_dis),
K = ncol(X_dis),
X = X_dis,
y = y_dis_0_1,
mu = b_con,        # example prior mean
Sigma = Sigma_con    # example covariance (wide prior)
)
discordant_model = tryCatch({
#for other aphas you would need to get the posterior for treatment effect and take the quarantines of that. you can get that from: post <- rstan::extract(fit); w_samples <- post$beta[, 1]
summary(stan(file = "mvn_logistic.stan", data = data_list, refresh = 0))$summary[1, c("mean", "sd", "2.5%", "97.5%")]
# rstanarm::stan_glm(
#   y_dis_0_1 ~ 0 + w_dis + X_dis,
#   family = binomial(link = "logit"),
#   prior = rstanarm::normal(location = prior_means, scale = prior_cov_no_intercept),
#   data = data.frame(y_dis_0_1, w_dis, X_dis),
#   refresh = 0
# )
}, error = function(e) {
warning(sprintf("stan_glm failed: %s", e$message))
NULL
})
ret = list()
if (!is.null(discordant_model)){
ret$betaT = discordant_model[1]
ret$ssq_beta_T = discordant_model[2]
ret$reject = !(discordant_model[3] < 0 & discordant_model[4] > 0)
ret$pval = if (ret$reject == 1) {0} else {1}
}
return(ret)
}
Do_Inference = function(y, X, w, strat, beta_T, n, X_style, true_funtion, regress_on_X) {
res = data.frame(
n = numeric(),
beta_T = numeric(),
X_style = character(),
true_funtion = character(),
regress_on_X = character(),
inference = character(),
beta_hat_T = numeric(),
pval = numeric()
)
matched_data =
process_matched_pairs(
strata = strat,
y = y,
X = data.matrix(X),
treatment = w
)
X_con =         matched_data$X_reservoir_concordant
y_con =         matched_data$y_reservoir_concordant
w_con = matched_data$treatment_reservoir_concordant
X_dis =             matched_data$X_diffs_discordant
y_dis =             matched_data$y_diffs_discordant
w_dis =     matched_data$treatment_diffs_discordant
dis_idx =      matched_data$discordant_idx
if (regress_on_X %in% c("all", "one")) {
discordant_viabele = if(length(y_dis) > ncol(X) + 7) { TRUE } else { FALSE }
concordant_viabele = if(length(y_con) > ncol(X) + 7) { TRUE } else { FALSE }
########################### CLOGIT  ###########################
beta_hat_T = NA; ssq_beta_hat_T = NA; pval = NA
if (discordant_viabele) {
y_dis_0_1 = ifelse(y_dis == -1, 0, 1)
model = summary(glm(y_dis_0_1 ~ 0 + w_dis + X_dis, family = "binomial"))$coefficients[1,c(1,2)]
beta_hat_T = model[1]; ssq_beta_hat_T = model[2]
pval = 2 * pnorm(min(c(-1,1) * (beta_hat_T / ssq_beta_hat_T)))
}
res = rbind(res, data.frame(
n = n,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "clogit",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
# ########################### DISCORDANT  ###########################
# beta_hat_T = NA; ssq_beta_hat_T = NA; pval = NA
# if (discordant_viabele) {
#   model = summary(glm(y[dis_idx] ~ w[dis_idx] + X[dis_idx,], family = "binomial"))$coefficients[2,c(1,2)]
#   beta_hat_T = model[1]; ssq_beta_hat_T = model[2]
#   pval = 2 * pnorm(min(c(-1,1) * (beta_hat_T / ssq_beta_hat_T)))
# }
# res = rbind(res, data.frame(
#   n = n,
#   beta_T = beta_T,
#   X_style = X_style,
#   true_funtion = true_funtion,
#   regress_on_X = regress_on_X,
#   inference = "discordant",
#   beta_hat_T = beta_hat_T,
#   ssq_beta_hat_T = ssq_beta_hat_T,
#   pval = pval
# ))
########################### LOGIT  ###########################
beta_hat_T = NA; ssq_beta_hat_T = NA; pval = NA
if (TRUE) {
model = summary(glm(y ~ w + X, family = "binomial"))$coefficients[2,c(1,2)]
beta_hat_T = model[1]; ssq_beta_hat_T = model[2]
pval = 2 * pnorm(min(c(-1,1) * (beta_hat_T / ssq_beta_hat_T)))
}
res = rbind(res, data.frame(
n = n,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "logit",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
########################### BAYESIAN NO T PRIOR ###########################
beta_hat_T = NA; ssq_beta_hat_T = NA; pval = NA; pval_freq = NA
if (discordant_viabele & concordant_viabele) {
model = Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, FALSE)
beta_hat_T = model$betaT; ssq_beta_hat_T = model$ssq_beta_T
pval = model$pval
#pval_freq = 2 * pnorm(min(c(-1,1) * (beta_hat_T / ssq_beta_hat_T)))
}
res = rbind(res, data.frame(
n = n,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "bayesian",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
# res = rbind(res, data.frame(
#   n = n,
#   beta_T = beta_T,
#   X_style = X_style,
#   true_funtion = true_funtion,
#   regress_on_X = regress_on_X,
#   inference = "bayesian no T prior pavl-freq",
#   beta_hat_T = beta_hat_T,
#   ssq_beta_hat_T = ssq_beta_hat_T,
#   pval = pval_freq
# ))
# ########################### BAYESIAN ###########################
# beta_hat_T = NA; ssq_beta_hat_T = NA; pval = NA; pval_freq = NA
# if (discordant_viabele & concordant_viabele) {
#   model = Bayesian_Clogit(y_dis, X_dis, w_dis, y_con, X_con, w_con, TRUE)
#   beta_hat_T = model$betaT; ssq_beta_hat_T = model$ssq_beta_T
#   pval = model$pval
#   #pval_freq = 2 * pnorm(min(c(-1,1) * (beta_hat_T / ssq_beta_hat_T)))
# }
# res = rbind(res, data.frame(
#   n = n,
#   beta_T = beta_T,
#   X_style = X_style,
#   true_funtion = true_funtion,
#   regress_on_X = regress_on_X,
#   inference = "bayesian",
#   beta_hat_T = beta_hat_T,
#   ssq_beta_hat_T = ssq_beta_hat_T,
#   pval = pval
# ))
#
# # res = rbind(res, data.frame(
# #   n = n,
# #   beta_T = beta_T,
# #   X_style = X_style,
# #   true_funtion = true_funtion,
# #   regress_on_X = regress_on_X,
# #   inference = "bayesian pavl-freq",
# #   beta_hat_T = beta_hat_T,
# #   ssq_beta_hat_T = ssq_beta_hat_T,
# #   pval = pval_freq
# # ))
########################### glmmTMB  ###########################
beta_hat_T = NA; ssq_beta_hat_T = NA; pval = NA
tryCatch({
fit_tmb = glmmTMB(
y ~ X + w + (1 | strat),
family = binomial(),
data   = data.frame(y, X, w, strat)
)
model = summary(fit_tmb)$coefficients$cond["w", c("Estimate", "Std. Error")]
beta_hat_T = model[1]; ssq_beta_hat_T = model[2]
pval = 2 * pnorm(min(c(-1,1) * (beta_hat_T / ssq_beta_hat_T)))
}, error = function(e) {
beta_hat_T <<- NA; ssq_beta_hat_T <<- NA; pval <<- NA
})
res = rbind(res, data.frame(
n = n,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "glmmTMB",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
########################### GEE  ###########################
beta_hat_T = NA; ssq_beta_hat_T = NA; pval = NA
tryCatch({
fit_gee = geeglm(
y ~ X + w,
id    = strat,
family = binomial(link = "logit"),
corstr = "exchangeable",
data   = data.frame(y, X, w, strat)
)
model = summary(fit_gee)$coefficients["w", c("Estimate", "Std.err")]
beta_hat_T = as.numeric(model[1]); ssq_beta_hat_T = as.numeric(model[2])
pval = 2 * pnorm(min(c(-1,1) * (beta_hat_T / ssq_beta_hat_T)))
}, error = function(e) {
beta_hat_T <<- NA; ssq_beta_hat_T <<- NA; pval <<- NA
})
res = rbind(res, data.frame(
n = n,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "GEE",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
} else { #if no x then remove the x parameter
discordant_viabele = if(length(y_dis) > 5) { TRUE } else { FALSE }
########################### CLOGIT  ###########################
beta_hat_T = NA; ssq_beta_hat_T = NA; pval = NA
if (discordant_viabele) {
y_dis_0_1 = ifelse(y_dis == -1, 0, 1)
model = summary(glm(y_dis_0_1 ~ 0 + w_dis, family = "binomial"))$coefficients[1,c(1,2)]
beta_hat_T = model[1]; ssq_beta_hat_T = model[2]
pval = 2 * pnorm(min(c(-1,1) * (beta_hat_T / ssq_beta_hat_T)))
}
res = rbind(res, data.frame(
n = n,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "clogit",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
# ########################### DISCORDANT  ###########################
# beta_hat_T = NA; ssq_beta_hat_T = NA; pval = NA
# if (discordant_viabele) {
#   model = summary(glm(y[dis_idx] ~ w[dis_idx], family = "binomial"))$coefficients[2,c(1,2)]
#   beta_hat_T = model[1]; ssq_beta_hat_T = model[2]
#   pval = 2 * pnorm(min(c(-1,1) * (beta_hat_T / ssq_beta_hat_T)))
# }
# res = rbind(res, data.frame(
#   n = n,
#   beta_T = beta_T,
#   X_style = X_style,
#   true_funtion = true_funtion,
#   regress_on_X = regress_on_X,
#   inference = "discordant",
#   beta_hat_T = beta_hat_T,
#   ssq_beta_hat_T = ssq_beta_hat_T,
#   pval = pval
# ))
########################### LOGIT  ###########################
beta_hat_T = NA; ssq_beta_hat_T = NA; pval = NA
if (discordant_viabele) {
model = summary(glm(y ~ w, family = "binomial"))$coefficients[2,c(1,2)]
beta_hat_T = model[1]; ssq_beta_hat_T = model[2]
pval = 2 * pnorm(min(c(-1,1) * (beta_hat_T / ssq_beta_hat_T)))
}
res = rbind(res, data.frame(
n = n,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "logit",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
########################### glmmTMB  ###########################
beta_hat_T = NA; ssq_beta_hat_T = NA; pval = NA
tryCatch({
fit_tmb = glmmTMB(
y ~ w + (1 | strat),
family = binomial(),
data   = data.frame(y, X, w, strat)
)
model = summary(fit_tmb)$coefficients$cond["w", c("Estimate", "Std. Error")]
beta_hat_T = model[1]; ssq_beta_hat_T = model[2]
pval = 2 * pnorm(min(c(-1,1) * (beta_hat_T / ssq_beta_hat_T)))
}, error = function(e) {
beta_hat_T <<- NA; ssq_beta_hat_T <<- NA; pval <<- NA
})
res = rbind(res, data.frame(
n = n,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "glmmTMB",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
########################### GEE  ###########################
beta_hat_T = NA; ssq_beta_hat_T = NA; pval = NA
tryCatch({
fit_gee = geeglm(
y ~ w,
id    = strat,
family = binomial(link = "logit"),
corstr = "exchangeable",
data   = data.frame(y, X, w, strat)
)
model = summary(fit_gee)$coefficients["w", c("Estimate", "Std.err")]
beta_hat_T = as.numeric(model[1]); ssq_beta_hat_T = as.numeric(model[2])
pval = 2 * pnorm(min(c(-1,1) * (beta_hat_T / ssq_beta_hat_T)))
}, error = function(e) {
beta_hat_T <<- NA; ssq_beta_hat_T <<- NA; pval <<- NA
})
res = rbind(res, data.frame(
n = n,
beta_T = beta_T,
X_style = X_style,
true_funtion = true_funtion,
regress_on_X = regress_on_X,
inference = "GEE",
beta_hat_T = beta_hat_T,
ssq_beta_hat_T = ssq_beta_hat_T,
pval = pval
))
}
rownames(res) = NULL
return(res)
}
Run_sim = function(beta_T, n, X_style) {
BIG_res = data.frame()
y = array(NA, n)
probs = array(NA, n)
if (X_style == "correlated") {
Sigma = 1 * (matrix(0.5, nrow = 6, ncol = 6) + diag(1 - 0.5, 6))
X = MASS::mvrnorm(n, rep(0, 6), Sigma) #error found in this line, the mean was set to 1, but it should have been 0
X = pnorm(X)
X = matrix(2*X - 1, ncol = 6)
} else {
X = matrix(runif(n * 6, min = -1, max = 1), ncol = 6)
}
df = data.frame(cbind(id = 1:n, X))
df.dist = gendistance(data.frame(df[, -1]), idcol = 1)
df.mdm = distancematrix(df.dist)
df.match = nonbimatch(df.mdm)
T_inx = df.match$halves[,2]
C_ind = df.match$halves[,4]
X = X[c(rbind(T_inx, C_ind)), ] #zip them together, so the mathces should be 1,1,2,2,3,3...
w = c(rbind(replicate(n/2, sample(c(0, 1)), simplify = TRUE)))
strat = rep(1:(n/2), each = 2)
for (true_funtion in true_funtions) {
if (true_funtion == "linear") {
beta_X = c(1, 1, 1, 1, 1, 1)
beta_0 = -1
probs = 1 / (1 + exp(-(beta_0 + (as.matrix(X) %*% beta_X) + beta_T * w)))
} else {
f_x = sin(pi * X[, 1] * X[, 2]) + X[,3]^3 + X[, 4]^2 + X[, 5]^2
probs = 1 / (1 + exp(-(f_x + beta_T * w)))
}
y = rbinom(n, 1, probs)
# ggplot(df, aes(x = probs, fill = factor(y))) +
#   geom_histogram(position = "identity", alpha = 0.6, bins = 30) +
#   labs(x = "Predicted probability", fill = "Outcome") +
#   scale_fill_manual(values = c("0" = "red", "1" = "blue")) +
#   theme_minimal()
for (regress_on_X in regress_on_Xs) {
# if (regress_on_X == "one") {
#   X_run = X[,1, drop = FALSE]
# } else {
#   X_run = X
# }
one_res = Do_Inference(y, X, w, strat, beta_T, n, X_style, true_funtion, regress_on_X)
BIG_res = rbind(BIG_res, one_res)
}
}
return(BIG_res)
}
handlers(global = TRUE)
handlers("txtprogressbar")
registerDoFuture()
plan(multisession, workers = num_cores)
for (e_nsim in 1:external_nsim) {
with_progress({
prog = progressor(along = 1:nrow(params))
results = foreach(row = iter(params, by = "row"),
.combine = rbind,
.packages = c("clogitR", "nbpMatching", "data.table",
"dplyr", "MASS", "Rcpp", "rstanarm")) %dorng% {
# extract parameters
nsim = row$nsim
beta_T = row$beta_T
n = row$n
X_style = row$X_style
res = tryCatch({
out = Run_sim(beta_T, n, X_style)
#cat("Successfully ran simulation")
prog()
out
}, error = function(e) {
cat(glue::glue("Error in nsim={nsim}: {e$message}"), '\n')
prog()  # still update progress bar even if it fails
NULL    # return NULL if failed, will be dropped in rbind
})
}
})
write.csv(results, file = paste0("C:/temp/clogitR_kap_test_from_scratch/100_", e_nsim, ".csv"), row.names = FALSE)
rm(results); gc()
}
plan(sequential)
